import ScrollableAnchor from 'react-scrollable-anchor'

import docsStyles from '$newdocs/components/DocsLayout/docsLayout.pcss'

<ScrollableAnchor id="intro-to-streams"><div>

## Intro to streams
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-in-core"><div>

## Work with streams in Core
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-via-sdks"><div>

## Work with streams via SDKs
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="work-with-streams-via-api"><div>

## Work with streams via API
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="data-signing-and-verification"><div>

## Data signing and verification

Authenticity and integrity of events published on a stream can be guaranteed with digital signatures. Every stream's metadata has a boolean `requiresSignedData` that can be set by the stream's owner to let subscribers know whether they should expect signed or unsigned events.

Every message published to a stream has six fields that uniquely identify this message across time, all streams and all publishers:

- `streamId`
- `streamPartititon`
- `timestamp`
- `sequenceNumber`
- `publisherId`
- `msgChainId`

More details about these fields can be found in the [protocol specification](TODO: insert link once merged). All together they form the message ID. They must be signed along with the actual message `content` to resist against replay attacks.

So the payload to be signed for every message by every publisher is the following:

```
payload = streamId + streamPartition + timestamp + sequenceNumber + publisherId + msgChaindId + content
```

The signing algorithm follows the convention described [here](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md). The secp256k1 ECDSA algorithm is applied on the keccak256 hash of a string derived from the challenge text:

```
signature = sign(keccak256("\x19Ethereum Signed Message:\\n" + len(payload) + payload)))
```

On the recipient side, every subscriber needs to verify signed events. If a received event is unsigned, the subscriber accepts the event if and only if the stream's boolean flag `requiresSignedData` is set to `false`.

The signature verification is done in three steps:

1. the subscriber extracts from the event and the signature the Ethereum address that signed the message (using the EC recover operation).
2. Check that the address recovered in step 1 matches the address defined by `publisherId`
3. Check that this `publisherId` belongs to the set of valid publishers for that stream by querying the `api/v1/streams/${id}/publishers` endpoint.

Both signature computation and verification are implemented in the Javascript and Java SDKs.

</div></ScrollableAnchor>

<ScrollableAnchor id="end-to-end-encryption"><div>

## End-to-end encryption
--content--

</div></ScrollableAnchor>

<ScrollableAnchor id="partitioning"><div>

## Partitioning
--content--

</div></ScrollableAnchor>
